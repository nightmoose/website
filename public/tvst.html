<!DOCTYPE html>
<html>
<head>
    <title>Tornadoes vs Tanks</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: linear-gradient(to bottom, skyblue, darkblue); font-family: Arial, sans-serif; }
        canvas { display: block; touch-action: none; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // First principles sizing: full screen, handle resize
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();
        
        // Game state
        let tornado = { x: canvas.width / 2, y: canvas.height / 2, vx: 0, vy: 0, size: 40 };
        let tanks = [];
        let particles = [];
        let score = 0;
        let gameSpeed = 1;
        let freezeTime = 0;
        let touchX = 0, touchY = 0;
        let firstTouch = true;
        let restartBtn = { x: 0, y: 0, w: 0, h: 0 };
        
        // Sounds: pure Web Audio API (no files)
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playBoom() {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = 200;
            osc.type = 'sawtooth';
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.1);
        }
        function playSlurp() {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = 800;
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.2);
        }
        function playBigBoom() {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = 80;
            osc.type = 'sawtooth';
            gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.3);
        }
        
        // Spawn tank: random bottom spawn, left/right drift, rare red boss tanks (now 6%)
        function spawnTank() {
            const isRed = Math.random() < 0.06;
            tanks.push({
                x: Math.random() * canvas.width,
                y: canvas.height + 50,
                vx: (Math.random() - 0.5) * 100 * gameSpeed,
                vy: -80 * gameSpeed,
                size: 20 + Math.random() * 20 + (isRed ? 20 : 0),
                type: isRed ? 'red' : 'green'
            });
        }
        
        // Particles: explosion confetti
        function addParticles(x, y, count = 15, hueStart = 300, hueRange = 60) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 200,
                    vy: (Math.random() - 0.5) * 200,
                    life: 1,
                    color: `hsl(${hueStart + Math.random() * hueRange}, 100%, 60%)`
                });
            }
        }
        
        // Input handlers: pixel-perfect with DPI scaling
        function getCanvasPos(e, isTouch) {
            const rect = canvas.getBoundingClientRect();
            const clientX = isTouch ? e.touches[0].clientX : e.clientX;
            const clientY = isTouch ? e.touches[0].clientY : e.clientY;
            return {
                x: (clientX - rect.left) * (canvas.width / rect.width),
                y: (clientY - rect.top) * (canvas.height / rect.height)
            };
        }
        
        function handleStart(e, isTouch) {
            e.preventDefault();
            const pos = getCanvasPos(e, isTouch);
            if (pos.x >= restartBtn.x && pos.x <= restartBtn.x + restartBtn.w &&
                pos.y >= restartBtn.y && pos.y <= restartBtn.y + restartBtn.h) {
                // RESTART!
                score = 0;
                gameSpeed = 1;
                tanks.length = 0;
                particles.length = 0;
                freezeTime = 0;
                tornado.x = canvas.width / 2;
                tornado.y = canvas.height / 2;
                tornado.vx = 0;
                tornado.vy = 0;
                spawnTank();
                return;
            }
            // First touch unlock
            if (firstTouch) {
                audioCtx.resume();
                firstTouch = false;
                spawnTank();
            }
        }
        
        canvas.addEventListener('touchstart', (e) => handleStart(e, true), { passive: false });
        canvas.addEventListener('mousedown', (e) => handleStart(e, false));
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const pos = getCanvasPos(e, true);
            touchX = pos.x;
            touchY = pos.y;
        }, { passive: false });
        
        canvas.addEventListener('mousemove', (e) => {
            const pos = getCanvasPos(e, false);
            touchX = pos.x;
            touchY = pos.y;
        });
        
        // Main loop: 60fps, physics first principles (velocity, damping)
        function loop(time) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update button position (responsive)
            const btnMargin = 20;
            restartBtn.w = Math.min(160, canvas.width * 0.35);
            restartBtn.h = 60;
            restartBtn.x = canvas.width - restartBtn.w - btnMargin;
            restartBtn.y = btnMargin;
            
            // Freeze timer
            if (freezeTime > 0) freezeTime--;
            
            // Tornado physics: lerp to touch + momentum
            const dx = touchX - tornado.x;
            const dy = touchY - tornado.y;
            tornado.vx = tornado.vx * 0.85 + dx * 0.1;
            tornado.vy = tornado.vy * 0.85 + dy * 0.1;
            tornado.x += tornado.vx;
            tornado.y += tornado.vy;
            tornado.x = Math.max(tornado.size, Math.min(canvas.width - tornado.size, tornado.x));
            tornado.y = Math.max(tornado.size, Math.min(canvas.height - tornado.size, tornado.y));
            
            // Draw tornado: funnel swirl
            const grad = ctx.createRadialGradient(tornado.x, tornado.y, 0, tornado.x, tornado.y, tornado.size * 1.5);
            grad.addColorStop(0, 'rgba(150,150,150,0.8)');
            grad.addColorStop(0.5, 'rgba(100,100,100,0.6)');
            grad.addColorStop(1, 'rgba(200,200,200,0)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(tornado.x, tornado.y, tornado.size * 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'rgba(200,200,200,0.5)';
            ctx.lineWidth = 3;
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.arc(tornado.x, tornado.y, tornado.size, i * Math.PI * 0.4, (i * Math.PI * 0.4) + 0.3);
                ctx.stroke();
            }
            
            // Update/draw tanks
            for (let i = tanks.length - 1; i >= 0; i--) {
                const tank = tanks[i];
                
                // Physics only if not frozen
                if (freezeTime <= 0) {
                    tank.x += tank.vx * 0.016;
                    tank.y += tank.vy * 0.016;
                }
                
                // Draw tank with blink/freeze effect
                ctx.save();
                if (freezeTime > 0) {
                    const pulse = 0.4 + 0.6 * Math.sin(time * 0.025 + i * 0.5);
                    ctx.globalAlpha = pulse;
                }
                
                // Body color
                ctx.fillStyle = tank.type === 'red'
                    ? `hsl(${10 + Math.sin(time * 0.01 + i * 10) * 10}, 90%, 45%)`
                    : `hsl(${120 + Math.sin(time * 0.01 + i) * 30}, 70%, 40%)`;
                ctx.beginPath();
                ctx.ellipse(tank.x, tank.y, tank.size * 0.8, tank.size * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Treads
                ctx.fillStyle = tank.type === 'red'
                    ? 'rgba(150,0,0,0.8)'
                    : 'rgba(0,100,0,0.8)';
                ctx.fillRect(tank.x - tank.size * 0.6, tank.y + tank.size * 0.2, tank.size * 1.2, tank.size * 0.15);
                
                ctx.restore();
                
                // Collision: distance < sum sizes
                const dist = Math.hypot(tank.x - tornado.x, tank.y - tornado.y);
                if (dist < tank.size + tornado.size) {
                    const points = tank.type === 'red' ? 10 : 1;
                    score += points;
                    if (tank.type === 'red') {
                        playBigBoom();
                        addParticles(tank.x, tank.y, 50, 0, 45); // Fiery blast
                        freezeTime = 120; // 2s
                        gameSpeed = 1; // RESET SPEED!
                    } else {
                        playBoom();
                        playSlurp();
                        addParticles(tank.x, tank.y);
                        gameSpeed += 0.01; // Ramp greens
                    }
                    tanks.splice(i, 1);
                } else if (tank.y < -100) {
                    tanks.splice(i, 1);
                }
            }
            
            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * 0.016;
                p.y += p.vy * 0.016;
                p.vy += 200 * 0.016;
                p.life -= 0.02;
                ctx.save();
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                if (p.life <= 0) particles.splice(i, 1);
            }
            
            // Spawn logic: 1-3/sec ramping
            if (Math.random() < 0.05 * gameSpeed) spawnTank();
            
            // UI: FREEZE! overlay
            if (freezeTime > 0) {
                ctx.save();
                ctx.globalAlpha = 0.8 + 0.2 * Math.sin(time * 0.05);
                ctx.fillStyle = '#00FFFF';
                ctx.font = `${Math.min(canvas.width * 0.15, 100)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('FREEZE!', canvas.width / 2, canvas.height / 2);
                ctx.restore();
            }
            
            // Restart button: pulsing top-right
            ctx.save();
            const pulse = 0.6 + 0.4 * Math.sin(time * 0.008);
            ctx.globalAlpha = pulse;
            ctx.fillStyle = 'rgba(0,100,200,0.4)';
            ctx.fillRect(restartBtn.x, restartBtn.y, restartBtn.w, restartBtn.h);
            ctx.globalAlpha = pulse * 0.8;
            ctx.strokeStyle = 'rgba(255,255,255,1)';
            ctx.lineWidth = 4;
            ctx.strokeRect(restartBtn.x, restartBtn.y, restartBtn.w, restartBtn.h);
            ctx.globalAlpha = pulse;
            ctx.fillStyle = 'white';
            ctx.font = `bold ${Math.min(32, restartBtn.w * 0.18)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('RESTART', restartBtn.x + restartBtn.w / 2, restartBtn.y + restartBtn.h / 2);
            ctx.restore();
            
            // Big score (center top)
            ctx.fillStyle = 'white';
            ctx.font = `${Math.min(canvas.width * 0.1, 80)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(score, canvas.width / 2, 100);
            ctx.font = `${Math.min(canvas.width * 0.05, 40)}px Arial`;
            //ctx.fillText('Slurp the Tanks!', canvas.width / 2, canvas.height - 50);
            
            requestAnimationFrame(loop);
        }
        
        loop(0);
    </script>
</body>
</html>